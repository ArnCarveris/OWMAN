\documentclass[12pt,a4paper]{article}
\usepackage[latin1]{inputenc}
\usepackage{amsmath}
\usepackage{amsfonts}
\usepackage{amssymb}
\usepackage{graphicx}
\usepackage{float}
\usepackage{amsmath}
\usepackage{url}
\usepackage{hyperref}
\usepackage{listings}	% syntax highlight
\usepackage{verbatim}
\usepackage{minted}

\graphicspath{ {img/} }
\begin{document}

\title{ Open World Streaming: \linebreak
Automatic memory management in open world games without loading screens. }

\author{Alejandro Juan Pérez}

\maketitle

\newpage

\tableofcontents

\newpage

\section{Introduction}


Open world games are among the most appreciated games by players. They provide users the chance to explore a big world and they are very immersive.  Open world games grant players the freedom to take any decision and enjoy their high interaction.

As you might already know, in open world games the player usually controls an avatar over a big virtual world. So the player that controls the avatar takes its skin and, ideally, gets immersed in the virtual world.

Sure you know about some of the most famous open world games. Some of them are: \emph{Grad Theft Auto} series (by \emph{Rockstar}), \emph{The Elder Of Scrolls} series (by \emph{Bethesda}), \emph{Minecraft} (by \emph{Mojang}). These games, apart from being very famous, have all been in the top of the best-selling videogames. Let's see some examples. \emph{Minecraft} has sold 19 million copies for the PC platform and it is the most sold PC game ever. Grand Theft Auto V has sold 19 millons copies for the \emph{PS3}, making it the most sold \emph{PS3} game ever. The \emph{Eder Scrolls: Skyrim} has sold 20 millon copies for \emph{PC}, \emph{XBOX} and \emph{PS3}\cite{bestselling}.

Therefore, open world games are not only about fun, freedom and high interaction but also a promising business. And as we will see they are technologically challenging.

Despite open world games are well know, the techniques that are applied in their implementation are not. Game studios that are experienced in the implementation of open world games, like \emph{Rockstar}, keep well their secrets. The development of open world game engines requires a great investment.

The purpose of this project is to develop a game engine that will support making open world videogames. Our engine should allow the creation of games with huge worlds and avoid loading screens.

\section{Requirements}

So we are willing to make a game engine that supports the development of open world games. We are going to focus on the requirements that are more specific for open world games. And requirements that are common for most game engines will be left as secondary requirements.

\subsection{Main requirements}

We consider these requirements are the main target to accomplish.

\begin{itemize}

\item \textbf{Visualization:} We said that requirements that are common for any game engine? will be treated as secondary requirements. But this is an exception. It is very important to have some kind of visual feedback. We need visualization to test our system. Also, it is important in order to prove that our engine is working properly. So we need to implement a graphical interface even if it is not very fancy. The graphics will be 2-dimensional.

\item \textbf{Memory management:} If there is one thing that characterizes open world games is that they usually have very big worlds. These worlds have a huge amounts of data (entities, textures, meshes, sound, etc). Some of this games require several tens of gigabytes of compressed data in secondary disk. Obviously we can not expect our users to have that much RAM capacity. The main challenge will be to keep memory consumption to a minimum while not compromising playability or quality. The tick we are going to use is to load into main memory only the things that are closer to the player. Another thing that we will do is to avoid duplicated resources in RAM. For example, there are is a forest that has many trees that share the same set textures, we must accomplish that each texture is in RAM at most once.

\item \textbf{Accurate physics simulation:} Again, this is a feature that most game engines incorporate. But it is important as a main requirement because accuracy in open world games carry challenges that must be solved. We will talk about this topic later because it is complex and requires its own space.

\item \textbf{Easy to use:} It is important that making games with our game engine is as easy as any of the engines we are used to. If our engine was too difficult to use nobody would use it.

\item \textbf{Testable:} We want to be able to see if our engine is working as expected.

\end{itemize}

\subsection{Secondary Requirements}

These requirements would be great to implement for a commercial game engine but not the main target of this academic work.

\begin{itemize}

\item \textbf{Sound:} Every game engine has sound and it is not an issue in open world games.

\item \textbf{Scripting:} We could embed some scripting language as it is done in most game engines.

\item \textbf{Advanced graphics:} They have nothing to do with world streaming.

\item \textbf{Persistency:} It would by great if changes made to the world were persistent.

\item \textbf{Efficiency:} Saving computational resources in world streaming will make them available for other tasks like physics simulation or artificial intelligence.

\end{itemize}



\section{Level-based videogames}


Traditionally games have been structured in levels.
In this kind of games the player must complete the current level to advance to the next one. Once one level is completed that level doesn't need to remain in main memory therefore resources can be deleted.
The mechanics of this type of games allows to manage the resources of the game in an easy and efficient way.

\begin{figure}[H]
	\centering
	\includegraphics[scale=0.7]{level_loading_mechanics.pdf}
	\caption{Level loading mechanics}
	\label{fig:level_loading_mechanics}
\end{figure}

It is well know that computers(and other gaming devices) usually have two types of memory.
The first memory is the one we usually call main memory. Main memory is fast and slow.
The second memory is the secondary storage memory. This one is slow and big. Changing of level requires loading all the resources of the next level from secondary memory and, therefore, it is slow. That's why in most level-based games changing of level will pop-up a loading screen.and the player has to wait for a while.

\begin{figure}[H]
	\centering
	\includegraphics[scale=0.7]{loading_sonic.png}
	\caption{One loading screen from \emph{Sonic}}
	\label{fig:loading_sonic}
\end{figure}

Some times the designers of the game use the loading screen to give tips to the player.

The approach used by level-based games is not useful for open world games we need world streaming in order to avoid loading screens.

\section{World streaming}

World streaming consists on loading game resources on demand. The concept is very similar to video streaming. In video streaming the data is sent from disk or from the network as it is needed. So in world streaming the game contents are taken from the disk (or from the network) to main memory as they are needed.
In contrast to video streaming, world streaming is not as straightforward. In video streaming the data is sequential, that is, you know what comes after. World streaming is different because what comes next depends on what the user does. So we must have the data prepared for all the decisions the user can make.
Imagine the case of platform game such as \emph{Terraria}. \emph{Terraria} is a 2D game that has an enormous map.

\begin{figure}[H]
	\centering
	\includegraphics[scale=0.6]{terraria.jpg}
	\caption{Screenshot of \emph{Terraria}}
	\label{fig:terraria}
\end{figure}

In \emph{Terraria} the player can move in four directions (up, down, left, right). So when the user chooses to go to any of the four directions the data must be already prepared in main memory no mater what key is pressed.

\subsection{Examples of games using world streaming}

"Streaming is the backbone of everything we do. Everyone at the company understands how it's structured." said Adam Fowler, the Technical director at Rockstar North \cite{rockstar}.
Companies, such as Rockstar, know that world streaming is the technology that supports their success.

In this section we are going to show some of the most relevant games supported by the world streaming technology.

\paragraph{Hunter - Paul Holmes (1991)}

Hunter is one of the main influences of GTA (Grand Theft Auto). Hunter is a 3D action-adventure game in which the player could travel around a pretty big world. The degree of freedom in this game was enormous. There were many vehicles (bicycles, cars, ships, tanks, airplanes), places, and weapons. It is certainly not the first open world game but from the information we have I could affirm it might be the first game that used some kind of world streaming.

\begin{figure}[H]
	\centering
	\includegraphics[scale=0.7]{hunter.jpg}
	\caption{Screenshot of \emph{Hunter}}
	\label{fig:hunter}
\end{figure}

In this game there were missions that could be completed but it was the player who decided whether or not to complete them.

Hunter was released for Amiga and Atari. The acceptance of the game was great and magazines ranked it with high scores.


\paragraph{Grand Theft Auto - Tarantula Studios (1997)}

This was the first Grand Theft Auto. With an enormous city and \emph{mainly} 2D graphics, GTA was the one that started the famous series of violent games. The player takes the role of a criminal that can drive all around the city without loading screens.

\begin{figure}[H]
	\centering
	\includegraphics[scale=0.8]{gta.jpg}
	\caption{Screenshot of \emph{GTA}}
	\label{fig:gta}
\end{figure}

The game was released in 1997 for PC and PlayStation, and in 1998 for GameBoy Color. The GBC (GameBoy Color) version is considered to be a great technological achievement due to the hardware limitations of the portable console. The first GTA was successful in sells mainly thanks to the GBC version but magazines and users rated it low\cite{gta1}.


\paragraph{Midnight Club: Street Racing - Angel Studios (2000)}

Midnight Club is a series of open world racing games. In this game you take the role of an urban street racer. The player can drive all around \emph{The Big Apple} and challenge other street racers. In the missions you will have to defeat your enemies and scape from the cops. Completing missions will provide you respect and money to buy new cars. But you can skip missions and just enjoy driving around New York.

\begin{figure}[H]
	\centering
	\includegraphics[scale=1]{midnight1.png}
	\caption{Screenshot of \emph{Midnight Club: Street Racing}}
	\label{fig:midnight1}
\end{figure}

This first Midnight Club was released in the same year that the PS2 (PlayStation 2) was commercialised. The acceptance of the public was good but sells were less than expected. One year later they released the GBA (GameBoy Advance) version which was rated poorly. Despite of its unfortunate sales this game is the one that started a successful saga.

\paragraph{Dungeon Siege - Gas Powered Games (2002)}

Dungeon Siege is a role-playing videogame very similar to \emph{Diablo} series. Scott Bilas, one of the developers of the game, published a very inspiring article about how the team managed to develop a game with such a big world\cite{worldbilas}. Thats to its flexible scripting engine the community was able to make modifications of the game, and even some people used the engine to make their own game. Despite the main story of the game is very linear there are many secondary missions and the player has quite freedom to move around. The greatest achievement of this game was avoiding all loading screens except for the initial one. Even taking portals is instantaneous. Graphics were impressive for the time being.

\begin{figure}[H]
	\centering
	\includegraphics[scale=0.75]{dungeon_siege_screenshot.jpg}
	\caption{Screenshot of \emph{Dungeon Siege}}
	\label{fig:dungeonsiege1}
\end{figure}

Dungeon Siege had an online mode too. In the online mode you could grab your friends and complete the adventure in company.

Dungeon Siege had good sales but maybe not as much as it deserved for its technological quality and good graphics design

\paragraph{Grand Theft Auto: San Andreas - Rockstar North (2004)}

After the \emph{Rockstar}'s successful titles \emph{GTA III} and \emph{GTA: Vice City}, it came an even more sold game: \emph{GTA: San Andreas}. Take the role of \emph{Carl Johnson}, the feared gangster. This game has one of the biggest maps in the history of videogames. There is complete freedom to wander around any of the tree enormous cities.

\begin{figure}[H]
	\centering
	\includegraphics[scale=1]{sanan.jpg}
	\caption{Screenshot of \emph{GTA: San Andreas}}
	\label{fig:sanan}
\end{figure}

\emph{San Andreas} is the most sold PS2 game ever. Very successful for the PC and XBOX platforms too. And not only that, the game is still having good sales for PC and Android.

\paragraph{World Of Warcraft - Blizzard (2004)}

\emph{World of Warcraft} (\emph{WoW}) is an MMORPG (massively multiplayer online role-playing game). This game has a different type of world streaming from the one we have seen so far. In this case the information that provides the status of the entities doesn't come from the hard disk but from the network. World streaming in the network is even more challenging but, for instance, resource management is very similar. This game has a big world and social interaction between players. Chatting, trading and fighting with other players is possible in \emph{WoW}.


\begin{figure}[H]
	\centering
	\includegraphics[scale=0.6]{wow.jpg}
	\caption{Screenshot of \emph{World of Warcraft}}
	\label{fig:wow}
\end{figure}

WoW has been the most played multiplayer game for many years and it is the game that provided most earnings of all times(\$10 billion)\cite{earnings}.

\paragraph{Fallout 3 - Bethesda Softworks (2008)}

World streaming is a feature present in many of the new-generation videogames. Fallout is just one of them that has an enormous world and impressive graphics.

\begin{figure}[H]
	\centering
		\includegraphics[scale=0.8]{fallout.jpeg}
	\caption{Screenshot of \emph{Fallout 3}}
	\label{fig:fallout}
\end{figure}


\paragraph{Minecraft - Mojang (2011)}

\emph{Minecraft} is the sandbox MMO that proved that games are not all about graphics.

\begin{figure}[H]
	\centering
	\includegraphics[scale=1]{minecraft.png}
	\caption{Screenshot of \emph{Minecraft}}
	\label{fig:minecraft}
\end{figure}

\emph{Minecraft} is the most sold PC game of all times.


\paragraph{Conclusion}

We have seen many games supported by the world streaming technology. The trend shows that open world games are becoming more popular and it does not seem it is going to stop.

\subsection{The strategy}

The most valuable source of information I have found about world streaming is an article called \emph{The Continuous World of Dungeon Siege} by \emph{Scott Bilas}\cite{worldbilas}. In this article, \emph{Scott Bilas} explains how they developed \emph{Dungeon Siege}. \emph{Dungeon Siege} is an open world 3D game released in 2002. It was developed by \emph{Gas Powered Games} and distributed by \emph{Microsoft}. In this article I have found many useful tips for implementing an open world streaming engine. \emph{Dungeon Siege} is a 3D game but you can only move in four directions (the world is landscape shaped). So the approach followed in \emph{Dungeon Siege} is similar to the one we would follow in a 2D game.

In \emph{Dungeon Siege} the world is divided into pieces of land which are aligned to a grid. These rectangles of land are called nodes. Any node can be connected to every other node. If two nodes are linked, that means that if the player is in one of them, he could travel to the other at any moment. Therefore, when the player is in one node we must be loading at least all the directly connected nodes. Normally the connections will match the adjacent pieces of land.

\begin{figure}[H]
	\centering
	\includegraphics[scale=1]{connections.pdf}
	\caption{Connections of adjacent pieces of land (we are not taking into account the diagonals)}
	\label{fig:connections}
\end{figure}

But there are cases in which two adjacent nodes could not be connected (e.g. there is a wall separating them). Or there could be nodes that are connected and are not adjacent (e.g. there is a portal that will teleport the player from one place to another).


\begin{figure}[H]
	\centering
	\includegraphics[scale=1]{connections2.pdf}
	\caption{Two nodes connected by a portal.}
	\label{fig:connections2}
\end{figure}

This node-based approach is the one used in Dungeon siege. The designers of the game used a custom tool that would allow to manage the connections of the nodes.

For our engine we are going to take a simpler approach and we will assume each node is connected to all the surrounding nodes (i.e 8 nodes at most). This will simplify the job of the designers of the game. With our approach taking portals will require a loading screen (which is very common current games).

\subsection{Loading Resources is slow}

Imagine that we have implemented our strategy and in a given moment the player has changed of node. We will have to load to main memory all the entities that are located in the new adjacent cell (or node). That implies: loading from disk the file that describes that cell, parsing that file in order to find the entities, loading all the resources that are required by the entities and finally creating the entities. So when the node had been loaded you would realize that you have spent 1 second (or much more) and in this time you haven't rendered a single frame!. Therefore, we have to solve this in some way.

The bottleneck here is the access to disk. Access to disk blocks the CPU and requires some time. So most of the time, when loading a new cell, the CPU would be idle while it could be doing important tasks (e.g. physics simulation or rendering). The solution that is suggested in the article of \emph{Scott Bilas} (and the one we have followed) is to use a separate thread for loading resources from disk. So if our main thread (the one that executes the main loop) needs to load a resource, instead of doing it itself, it asks the background thread to do it. This way, the main thread is never idle when there is job to be done and the secondary thread will be loading from disk at its own pace.

\begin{figure}[H]
	\centering
	\includegraphics[scale=0.7]{comic1.pdf}
	\caption{Two threads talking.}
	\label{fig:comic1}
\end{figure}

\section{The architecture of the engine}

Our game engine will be composed by some subsystems.
In order to work properly the components of the engine must interact with each other in some way.

\begin{figure}[H]
	\centering
	\includegraphics[scale=0.8]{architecture.pdf}
	\caption{Game engine architecture.}
	\label{fig:arch}
\end{figure}

The picture above is a simplification of the architecture. Notice that in the diagram only two subsystems are represented. The graphics and physics components are the most important subsystems, but there could be others like sound or artificial intelligence (AI).

\paragraph{Resource Manager:} The resource manager is the component in charge of accessing the file system. It runs on a separate thread so it does not interfere in the progress of other tasks. Also, it must assure that there will not be duplicated resources in main memory. The resource manager is used by all the other architecture components. So it takes the role of a servant for the others. In other to ease the access to this utility system, it is very convenient to implement it as a singleton.

\paragraph{World Streamer:} It is the one. The brain of the architecture. The world streamer is in charge of telling the subsystems below (graphics and physics in our diagram) what to do. It must decide whether a given entity must be loaded or not. An inefficient implementation of the world streamer would decide that all the entities of the world must be loaded. And a useless implementation of would not load any entity. So the world streamer needs to compute the subset of entities that must be loaded at any time. This subset of loaded entities is what we find in the diagram as "List of active entities".

\paragraph{Graphics System:} Might be called graphics engine too. It will get a list of entities that must be rendered from the world streamer. So it will be just told what should be displayed on the screen. The graphics system in independent from all the other components and does not care who is using it.

\paragraph{Physics System} Very similar to the graphics system. In the diagram you can appreciate the difference between these two: an extra arrow. This arrow flows from the physics system to to the world streamer. The meaning of this arrow is the position of the main character. After each physics simulation step the position of the main character might have changed and the world streamer needs this information in order to recompute the set of active entities.

\section{Implementation}

In this section I will explain briefly how I implemented the modules of the game engine.

\subsection{Graphics System}

The graphics system is implemented from scratch (there is a reason that will be explained later). Since implementing a graphics engine is not the purpose of this academic work, it does not have a big set of features.

\subsubsection{Architecture}
This graphics module is split in two layers. The first layer is the low-level layer. The low-level layer is the one that uses the OpenGL API (application programming interface). The purpose of the low-level layer is to provide a simple interface for the upper layer. This way the high-level layer does not need to understand any of OpenGL. So if we needed to deploy the application to a platform were DirectX performs better, we only would need to replace the low-level layer and the rest of the whole system would remain the same.

\begin{figure}[H]
	\centering
	\includegraphics[scale=0.8]{renderer.pdf}
	\caption{Graphics system architecture.}
	\label{fig:renderer}
\end{figure}

The low-level renderer API is just a reduced set of functions that allows to draw things on the screen. On the other hand the high-level renderer provides a class-based mechanism to define the scene. That is, in the low-level renderer we would say: "draw texture A in position X" and it will be shown on the screen for just this frame. And in the -high-level renderer we would say: "there exists a sprite in X and it has priority P" and it would be drawn on the screen until it is removed.

\subsubsection{Features}
The renderer I have implemented is not very sophisticated but works fine for our purpose. Animations are not yet supported. You can assign priorities to the sprites in order to define what is drawn on top. There is an abstraction of the camera too. The low-level renderer uses OpenGL ES (embedded systems), so it could be ported to mobile platforms.

\subsubsection{Why did I implement my own graphics engine?}

There are three reasons I had to implement a custom graphics engine.

\paragraph{Most graphics engines will manage resources automatically.}
Automatic resource management is one of the main targets of this academic work. If we had the render engine to do this for us, we would be missing something important. Even though, the graphics engines only manage graphics related resources and we would like to have resource management unified. What is more important, the resource manager of the graphics engines might be blocking.

\paragraph{OpenGL implementations do not support multithreading.}

OpenGL does not allow you to call its functions from threads other than the main thread. If you try to do so the behavior will be completely undefined \cite{multiopengl}.

Loading a graphics resource (like a texture) involves these steps:
\begin{itemize}

\item \textbf{Load the resource, which is stored in hard disk, to main memory.} This must be done by the secondary thread because we are accessing hard disk and that is slow.

\item \textbf{Allocate the resource in video card memory.} To render an object all its resources must be in the memory of the graphics card. To allocate, for instance, a texture in video memory we need to call OpenGL functions. That is the reason this step must be performed by the main thread (only the main thread is allowed to call OpenGL functions). Fortunately, the process copying a resource from RAM to VRAM if fast enough, so it does not block other tasks.

\item \textbf{Delete the resource in MM.} Once the resource is en VRAM we do not need it anymore en RAM. This task is not costly and could be performed by any thread. In our implementation it is deleted by the secondary thread because we think it makes more sense that the memory is released by the same thread it was allocated by. Also, in this way the code seems better encapsulated.

\end{itemize}

Most graphics engines provide functions to load graphics resources. And these functions do all the steps that we mentioned in a single call. Therefore, if we used one of these graphics engines, we would not be able to split the work among the two threads. Probably, there are workarounds that would allow to split tasks but they might difficult to implement. This is the main reason I have decided to make my own render engine.

\paragraph{I had personal interest in learning modern OpenGL.}

Also, I wanted an excuse to learn modern OpenGL features like shaders. The version of OpenGL I used is OpenGL ES 2.0. This version of OpenGL is compatible with embedded systems like smartphones. In this version you are forced to use shaders because all the fixed pipeline functionality has been removed. I will dedicate a section to explain briefly how to use shaders in modern OpenGL.

\subsubsection{Modern OpenGL programming}

I do not pretend to make a tutorial on modern OpenGL nor shaders but just to summarize what I have done.
I have used only the subset of API that is common to OpenGL 2.1 and OpenGL ES 2.0. In my testings, I used version 2.1, which is the one that runs on PC.

Since OpenGL does not support fixed pipeline functions I had to use shaders. What are shaders? Basically , they are pieces of code that run in the graphics card. They are used to achieve custom visual effects\cite{shader}. In OpenGL shaders are written in a specific programming language called GLSL. GLSL is very similar to C\cite{glsl}].

There are two types of shader.

\begin{itemize}

\item \textbf{Vertex shader.} Vertex shaders take as input one vertex and gives as output the position that vertex should take. It is used to achieve effects such as mesh deformation. One example where vertex shaders are used is the waves of the ocean. The vertex shader should change the position of vertices  so it fakes the water moving. In our 2D render engine, we do not need the vertex shader to do anything special: it just forwards the position as it is.

\begin{minted}{c}

#version 120

/**
 * In the vertex shader you are computing the position
 * of the current vertex.
 * Also you compute the texture coordinate corresponding
 * to this vertex.
 **/

// these are the parameters received by the main program
attribute vec2 inPosition;
attribute vec2 inTexCoords;

void main()
{
	
	// compute the position of the current vertex
	// In this case you are just forwarding the position,
	// but this allows you to achieva cool effects like the
	// mesh bending or the waves of the ocean
	// The fouth coordinate is called W(1.0) and it is used
	// for normalization purposes( read: 
	// "http://stackoverflow.com/questions/2422750/
	// in-opengl-vertex-shaders-what-is-w-and-why-do-i-divide-by-it" )
    gl_Position = vec4(inPosition, 0.0, 1.0);
    
    // compute the texture coordina corresponding to this
    // vertex
    gl_TexCoord[0] = vec4(inTexCoords, 0, 0);
    
}


\end{minted}

\item \textbf{Fragment shader.} Also called pixel shader but this term is more used for DierectX. Fragment shader is executed for every pixel and it should output the desired color for the current pixel. In our code we will be returning the color of the corresponding texture coordinate.

\begin{minted}{c}

#version 120

/**
 * In the fragment shader you are computing
 * which should be the color of the current pixel
 * ( fragment and pixel are sinonyms in OpenGL,
 * in fact in DirectX it is called pixel shader )
 * 
 * The output goes to -> gl_FragColor
 * 
 **/

uniform sampler2D tex;

void main()
{
	
	// take the color of the texture pixel
	vec4 color = texture2D(tex, gl_TexCoord[0].st);
	
	// output
    gl_FragColor = color;
    
}

\end{minted}


\end{itemize} 
  

Shaders are compiled are runtime. In the following picture there is a summary of the steps that are required to make a shader program.

\begin{figure}[H]
	\centering
	\includegraphics[scale=0.75]{shad.pdf}
	\caption{The process to compile and use shaders.}
	\label{fig:shad}
\end{figure}

Once you have built your shader program you can use it at any time. These are the tutorials I used \cite{shadtut} \cite{glmodtut} \cite{learngl}.

Since in modern OpenGL ES matrix operations (such as \emph{glRotatef()}) have been removed I had to use one geometry library: GLM\cite{glm}. For window management I used SDL2\cite{glm}. And for texture loading I employed SOIL\cite{soil}.

XML

\bibliography{tfg}

\begin{thebibliography}{99}

\bibitem{bestselling}
	\hypertarget{bestselling}
	List of the best-selling videogames.
	\newline
	\url{http://en.wikipedia.org/wiki/List_of_best-selling_video_games#All_platforms}
	
\bibitem{worldbilas}
	\hypertarget{worldbilas}
	The Continuous World of Dungeon Siege - Scott Bilas.
	\newline
	\url{http://scottbilas.com/files/2003/gdc_san_jose/continuous_world_paper.pdf}
	
\bibitem{rockstar}
	\hypertarget{rockstar}
	Technical leads Adam Fowler and Phil Hooker take us through the technology powering GTA V.
	\newline
	\url{http://www.develop-online.net/studio-profile/inside-rockstar-north-part-3-the-tech/0184140}
	
\bibitem{gta1}
	\hypertarget{gta1}
	GTA article at Wikipedia.
	\newline
	\url{http://en.wikipedia.org/wiki/Grand_Theft_Auto_%28video_game%29}

\bibitem{earnings}
	\hypertarget{earnings}
	Top 10 highest grossing videogames of all time.
	\newline
	\url{http://www.businessinsider.com/here-are-the-top-10-highest-grossing-video-games-of-all-time-2012-6?op=1}
	
\bibitem{multiopengl}
	\hypertarget{multiopengl}
	Stack Overflow post discouraging multithreaded rendering with OpenGL.
	\newline
	\url{http://stackoverflow.com/questions/11097170/multithreaded-rendering-on-opengl}
	
\bibitem{shader}
	\hypertarget{shader}
	Shaders on Wikipedia.
	\newline
	\url{http://en.wikipedia.org/wiki/Shader}
	
\bibitem{glsl}
	\hypertarget{glsl}
	GLSL on Wikipedia.
	\newline
	\url{http://en.wikipedia.org/wiki/OpenGL_Shading_Language}
	
\bibitem{shadtut}
	\hypertarget{shadtut}
	GLSL tutorial
	\newline
	\url{http://www.lighthouse3d.com/tutorials/glsl-tutorial}
	
\bibitem{glmodtut}
	\hypertarget{glmodtut}
	Modern OpenGL tutorial.
	\newline
	\url{https://open.gl}
	
\bibitem{learngl}
	\hypertarget{learngl}
	Learn OpenGL.
	\newline
	\url{http://www.learnopengl.com}
	
\bibitem{glm}
	\hypertarget{glm}
	GLM official webpage.
	\newline
	\url{http://glm.g-truc.net}

\bibitem{sdl}
	\hypertarget{sdl}
	SDL official webpage.
	\newline
	\url{https://www.libsdl.org}
	
\bibitem{soil}
	\hypertarget{soil}
	SOIL official webpage.
	\newline
	\url{http://www.lonesock.net/soil.html}
	
	
\end{thebibliography}


\end{document}

